# frm — библиотека валидации HTML-форм

`frm` — библиотека для синхронной валидации HTML-форм в браузере. Поддерживает строковые, числовые поля и группы чекбоксов. Валидация строится цепочками, ошибки накапливаются и доступны по каждому полю и по форме целиком.

---

## Требования

- Среда выполнения — браузер (DOM API).
- Поддерживаемые элементы формы:
  - `input[type="text"]`
  - `input[type="number"]`
  - `textarea`
  - `input[type="checkbox"]` (группы по `name`)
- Все элементы должны находиться внутри `HTMLFormElement`.
- Валидация синхронная.
- Асинхронные правила не поддерживаются.
- Поле начинает участвовать в валидации только после вызова `field(name)`.

---

## Архитектура

- `createFormValidator` — центральный объект, управляющий валидацией формы.
- `createFieldValidator` — фабрика валидаторов поля.

### Типы валидаторов

- строковый валидатор
- числовой валидатор
- валидатор массива (группа чекбоксов)

### Общие свойства валидаторов

- каждый валидатор хранит собственный список ошибок
- используется цепочный API
- ошибки очищаются при начале новой цепочки (`string()` / `number()`)

---

## API

### `createFormValidator(form: HTMLFormElement): TFormValidator`

Основной интерфейс работы с формой.

#### Свойства

- `form: HTMLFormElement`  
  ссылка на исходную форму

- `elements: TElementsAttributes[]`  
  метаданные элементов формы (элемент, имя, тип, required)

#### Методы

##### `field(name: string): TFieldValidator`

Возвращает валидатор поля по имени.

- поле должно существовать в форме
- при первом вызове поле регистрируется во внутреннем хранилище
- если поле не найдено — выбрасывается `Error`
##### `validate(): boolean`

Проверяет валидность всех зарегистрированных полей формы.

- учитываются только поля, для которых ранее был вызван `field(name)`
- если хотя бы у одного поля есть ошибки, возвращается `false`
- не запускает правила заново, а анализирует уже накопленные ошибки

##### `validateField(name: string): TElementValidity | null`

Возвращает результат валидации одного поля.

- если поле не зарегистрировано — возвращает `null`
- формат возвращаемого значения:

### getAllValidity(): TElementValidity[]

Возвращает массив валидностей всех зарегистрированных полей.

- неизвестные поля не включаются
- порядок соответствует порядку регистрации полей

---

## Строковый валидатор

Используется для:

- `input[type="text"]`
- `textarea`
- `select`

### Методы

#### string()

- начинает новую цепочку валидации
- очищает все предыдущие ошибки

#### required(message?: string)

- ошибка, если `value.trim()` пусто
- сообщение по умолчанию: `Поле обязательно`

#### minlength(length: number | string, message?: string)

- ошибка, если длина строки меньше `length`
- сообщение по умолчанию: `Минимум {length} символов`

#### maxlength(length: number | string, message?: string)

- ошибка, если длина строки больше `length`
- сообщение по умолчанию: `Максимум {length} символов`

#### email(message?: string)

- проверка по регулярному выражению
- пустое значение считается валидным, если не задан `required`
- сообщение по умолчанию: `Неверный email`

#### url(message?: string)

- проверка через `new URL()`
- пустое значение считается валидным
- сообщение по умолчанию: `Неверный URL`

#### custom(fn: (value: unknown) => boolean, message: string)

- пользовательская проверка значения строки
- если `fn` возвращает `false`, добавляется ошибка

#### number()

- переключение на числовой валидатор

#### getErrors(): string[]

- возвращает копию массива ошибок

---

## Числовой валидатор

Используется для `input[type="number"]`.

### Методы

#### number()

- начинает новую цепочку
- очищает предыдущие ошибки

#### required(message?: string)

- ошибка, если `value === ''`
- сообщение по умолчанию: `Поле обязательно`

#### min(value: number, message?: string)

- ошибка, если `Number(value) < min`
- сообщение по умолчанию: `Минимум {value}`

#### max(value: number, message?: string)

- ошибка, если `Number(value) > max`
- сообщение по умолчанию: `Максимум {value}`

#### integer(message?: string)

- ошибка, если значение не является целым числом
- сообщение по умолчанию: `Должно быть целым числом`

#### positive(message?: string)

- ошибка, если значение `<= 0`
- сообщение по умолчанию: `Должно быть положительным числом`

#### custom(fn: (value: unknown) => boolean, message: string)

- пользовательская проверка числового значения

#### string()

- переключение на строковый валидатор

#### getErrors(): string[]

- возвращает копию массива ошибок

### Особенность

`Number('') === 0`, поэтому без `required()` правила `min`, `max`, `integer`, `positive`
будут применяться к значению `0`.

---

## Валидатор группы чекбоксов

Используется для `input[type="checkbox"]` с одинаковым `name`.

Значение поля — массив выбранных значений `string[]`.

### Методы

#### string() / number()

- начинают новую цепочку
- очищают ошибки

#### required(message?: string)

- ошибка, если не выбран ни один чекбокс
- сообщение по умолчанию: `Необходимо выбрать хотя бы один вариант`

#### custom(fn: (values: unknown) => boolean, message: string)

- `fn` получает массив выбранных значений
- используется для проверки количества или конкретных вариантов

#### getErrors(): string[]

- возвращает массив ошибок

---

## Поведение и ограничения

- ошибки очищаются только при вызове `string()` или `number()`
- ошибки накапливаются в рамках одной цепочки
- `field(name)` выбрасывает `Error`, если поле отсутствует в форме
- `validateField(name)` возвращает `null` для незарегистрированного поля
- `validate()` проверяет только зарегистрированные поля
- валидация полностью синхронная
- radio-группы не выделены в отдельный тип валидатора

---

## Полнота

### Поддерживается

- цепочная валидация
- строковые и числовые правила
- кастомные проверки
- группы чекбоксов
- получение ошибок по каждому полю
- проверка формы целиком

### Не поддерживается

- асинхронная валидация
- вложенные структуры данных
- автоматическая регистрация всех полей формы
- отдельный валидатор для radio-кнопок

---

## Итог

`frm` — минималистичная библиотека валидации HTML-форм с явной регистрацией полей,
цепочным API и предсказуемым поведением без скрытой логики.